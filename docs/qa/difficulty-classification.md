# QA Difficulty Classification System

## Overview

This document defines the difficulty classification system for question-answer (QA) pair generation in Talk2Metadata. The system is designed specifically for **record localization tasks**, where the goal is to locate records in a target table by filtering through related tables via JOIN operations.

### Design Goals

1. **Quantifiable**: Each difficulty level corresponds to a clear numeric score
2. **Intuitive**: Encoding format is human-readable and self-explanatory
3. **Comprehensive**: Covers simple to expert-level queries
4. **Theoretically Grounded**: Based on Query Graph frameworks from Knowledge Graph research
5. **Practical**: Directly applicable to relational database schema and SQL generation

### Visual Overview

The following interactive visualization displays all 7 core query patterns (0, 1p, 2p, 2i, 3p, 3i, 4i) with:

- Pattern codes and base scores
- Complexity tiers (Easy, Medium, Hard, Expert)
- Structural diagrams showing JOIN relationships
- Concentric circle visualizations for path queries
- Star pattern diagrams for intersection queries

<style>
    .difficulty-table {
        width: 100%;
        border-collapse: collapse;
        margin: 30px 0;
    }
    .table-header {
        background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%);
        color: white;
    }
    .table-header th {
        padding: 20px;
        text-align: center;
        font-size: 1.1em;
        font-weight: 600;
    }
    .table-row {
        border-bottom: 1px solid #ecf0f1;
        transition: all 0.3s ease;
    }
    .table-row:hover {
        background: #f8f9fa;
        transform: scale(1.01);
        box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    }
    .table-cell {
        padding: 25px 20px;
        text-align: center;
        vertical-align: middle;
    }
    .difficulty-code {
        font-family: 'Courier New', monospace;
        font-size: 1.4em;
        font-weight: bold;
        padding: 8px 16px;
        border-radius: 8px;
        display: inline-block;
    }
    .difficulty-score {
        font-size: 1.2em;
        font-weight: bold;
        padding: 6px 12px;
        border-radius: 20px;
        background: rgba(0,0,0,0.1);
    }
    .difficulty-description {
        font-size: 1em;
        color: #5a6c7d;
        line-height: 1.4;
    }
    .tier-badge {
        display: inline-block;
        padding: 6px 12px;
        border-radius: 15px;
        font-size: 0.9em;
        font-weight: bold;
        color: white;
    }
    .tier-easy { background: #27ae60; }
    .tier-medium { background: #3498db; }
    .tier-hard { background: #e67e22; }
    .tier-expert { background: #8e44ad; }
    .pattern-cell {
        width: 220px;
    }
    .concentric-diagram {
        width: 200px;
        height: 240px;
        margin: 0 auto;
    }
</style>

<table class="difficulty-table">
    <thead class="table-header">
        <tr>
            <th>Pattern Code</th>
            <th>Base Score</th>
            <th>Complexity Tier</th>
            <th>Description</th>
            <th>Structure Diagram</th>
        </tr>
    </thead>
    <tbody id="difficulty-table-body">
        <!-- Table rows will be generated by JavaScript -->
    </tbody>
</table>

<script>
    (function() {
        const difficulties = [
            {code: '0', score: 0.0, color: '#27ae60', description: 'Direct query - no JOINs', pattern: 'direct', tier: 'Easy', hops: 0},
            {code: '1p', score: 1.0, color: '#3498db', description: 'Single-hop path query', pattern: 'path', tier: 'Medium', hops: 1},
            {code: '2p', score: 2.0, color: '#e67e22', description: 'Two-hop path query', pattern: 'path', tier: 'Hard', hops: 2},
            {code: '2i', score: 2.0, color: '#e74c3c', description: 'Two-way star query', pattern: 'star', tier: 'Hard', branches: 2},
            {code: '3p', score: 3.0, color: '#8e44ad', description: 'Three-hop path query', pattern: 'path', tier: 'Expert', hops: 3},
            {code: '3i', score: 3.0, color: '#9b59b6', description: 'Three-way star query', pattern: 'star', tier: 'Expert', branches: 3},
            {code: '4i', score: 4.0, color: '#6c3483', description: 'Four-way star query', pattern: 'star', tier: 'Expert', branches: 4}
        ];

        function createConcentricDiagram(difficulty) {
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', '100%');
            svg.setAttribute('height', '100%');
            svg.setAttribute('viewBox', '0 0 220 260');
            
            const centerX = 110; 
            const centerY = 130;
            
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            
            const gradient = document.createElementNS('http://www.w3.org/2000/svg', 'radialGradient');
            gradient.setAttribute('id', `gradient-${difficulty.code}`);
            gradient.setAttribute('cx', '50%');
            gradient.setAttribute('cy', '50%');
            gradient.setAttribute('r', '50%');
            
            const stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
            stop1.setAttribute('offset', '0%');
            stop1.setAttribute('stop-color', difficulty.color);
            stop1.setAttribute('stop-opacity', '0.15');
            
            const stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
            stop2.setAttribute('offset', '100%');
            stop2.setAttribute('stop-color', difficulty.color);
            stop2.setAttribute('stop-opacity', '0.05');
            
            gradient.appendChild(stop1);
            gradient.appendChild(stop2);
            defs.appendChild(gradient);
            
            const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
            marker.setAttribute('id', `arrowhead-${difficulty.code}`);
            marker.setAttribute('markerWidth', '6');
            marker.setAttribute('markerHeight', '4');
            marker.setAttribute('refX', '5');
            marker.setAttribute('refY', '2');
            marker.setAttribute('orient', 'auto');
            marker.setAttribute('markerUnits', 'strokeWidth');
            
            const arrowPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            arrowPath.setAttribute('d', 'M0,0 L0,4 L6,2 z');
            arrowPath.setAttribute('fill', difficulty.color);
            marker.appendChild(arrowPath);
            defs.appendChild(marker);
            
            svg.appendChild(defs);
            
            if (difficulty.pattern === 'direct') {
                const bgCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                bgCircle.setAttribute('cx', centerX);
                bgCircle.setAttribute('cy', centerY);
                bgCircle.setAttribute('r', '95');
                bgCircle.setAttribute('fill', `url(#gradient-${difficulty.code})`);
                bgCircle.setAttribute('stroke', 'none');
                svg.appendChild(bgCircle);
                
                const outerCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                outerCircle.setAttribute('cx', centerX);
                outerCircle.setAttribute('cy', centerY);
                outerCircle.setAttribute('r', '85');
                outerCircle.setAttribute('fill', 'none');
                outerCircle.setAttribute('stroke', difficulty.color);
                outerCircle.setAttribute('stroke-width', '2');
                outerCircle.setAttribute('stroke-opacity', '0.4');
                svg.appendChild(outerCircle);
                
                const centerDot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                centerDot.setAttribute('cx', centerX);
                centerDot.setAttribute('cy', centerY);
                centerDot.setAttribute('r', '8');
                centerDot.setAttribute('fill', difficulty.color);
                svg.appendChild(centerDot);
                
            } else if (difficulty.pattern === 'path') {
                const numHops = difficulty.hops;
                const minRadius = 25;
                const spacing = 30;
                
                const bgCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                bgCircle.setAttribute('cx', centerX);
                bgCircle.setAttribute('cy', centerY);
                bgCircle.setAttribute('r', minRadius + ((numHops + 1) * spacing));
                bgCircle.setAttribute('fill', `url(#gradient-${difficulty.code})`);
                bgCircle.setAttribute('stroke', 'none');
                svg.appendChild(bgCircle);
                
                for (let i = numHops; i >= 1; i--) {
                    const radius = minRadius + (i * spacing);
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', centerX);
                    circle.setAttribute('cy', centerY);
                    circle.setAttribute('r', radius);
                    circle.setAttribute('fill', 'none');
                    circle.setAttribute('stroke', difficulty.color);
                    circle.setAttribute('stroke-width', '2');
                    circle.setAttribute('stroke-opacity', 0.3 + (0.4 * (numHops - i + 1) / numHops));
                    svg.appendChild(circle);
                }
                
                for (let i = numHops; i >= 1; i--) {
                    const radius = minRadius + (i * spacing);
                    const angle = -Math.PI / 2;
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;
                    
                    if (i === 1) {
                        const lineEndX = centerX + Math.cos(angle) * 15;
                        const lineEndY = centerY + Math.sin(angle) * 15;
                        
                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line.setAttribute('x1', x);
                        line.setAttribute('y1', y);
                        line.setAttribute('x2', lineEndX);
                        line.setAttribute('y2', lineEndY);
                        line.setAttribute('stroke', difficulty.color);
                        line.setAttribute('stroke-width', '2.5');
                        line.setAttribute('stroke-linecap', 'round');
                        line.setAttribute('marker-end', `url(#arrowhead-${difficulty.code})`);
                        line.setAttribute('opacity', '0.8');
                        svg.appendChild(line);
                    } else {
                        const nextRadius = minRadius + ((i - 1) * spacing);
                        const nextX = centerX + Math.cos(angle) * (nextRadius + 8);
                        const nextY = centerY + Math.sin(angle) * (nextRadius + 8);
                        
                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line.setAttribute('x1', x);
                        line.setAttribute('y1', y);
                        line.setAttribute('x2', nextX);
                        line.setAttribute('y2', nextY);
                        line.setAttribute('stroke', difficulty.color);
                        line.setAttribute('stroke-width', '2.5');
                        line.setAttribute('stroke-linecap', 'round');
                        line.setAttribute('marker-end', `url(#arrowhead-${difficulty.code})`);
                        line.setAttribute('opacity', '0.8');
                        svg.appendChild(line);
                    }
                    
                    const dotShadow = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    dotShadow.setAttribute('cx', x + 1);
                    dotShadow.setAttribute('cy', y + 1);
                    dotShadow.setAttribute('r', '5');
                    dotShadow.setAttribute('fill', 'rgba(0,0,0,0.15)');
                    svg.appendChild(dotShadow);
                    
                    const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    dot.setAttribute('cx', x);
                    dot.setAttribute('cy', y);
                    dot.setAttribute('r', '5');
                    dot.setAttribute('fill', difficulty.color);
                    dot.setAttribute('stroke', 'white');
                    dot.setAttribute('stroke-width', '2');
                    svg.appendChild(dot);
                }
                
                const centerShadow = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                centerShadow.setAttribute('cx', centerX + 1);
                centerShadow.setAttribute('cy', centerY + 1);
                centerShadow.setAttribute('r', '8');
                centerShadow.setAttribute('fill', 'rgba(0,0,0,0.2)');
                svg.appendChild(centerShadow);
                
                const centerDot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                centerDot.setAttribute('cx', centerX);
                centerDot.setAttribute('cy', centerY);
                centerDot.setAttribute('r', '8');
                centerDot.setAttribute('fill', difficulty.color);
                centerDot.setAttribute('stroke', 'white');
                centerDot.setAttribute('stroke-width', '3');
                svg.appendChild(centerDot);
                
            } else if (difficulty.pattern === 'star') {
                const numBranches = difficulty.branches;
                const radius = 85;
                
                const bgCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                bgCircle.setAttribute('cx', centerX);
                bgCircle.setAttribute('cy', centerY);
                bgCircle.setAttribute('r', radius + 10);
                bgCircle.setAttribute('fill', `url(#gradient-${difficulty.code})`);
                bgCircle.setAttribute('stroke', 'none');
                svg.appendChild(bgCircle);
                
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', centerX);
                circle.setAttribute('cy', centerY);
                circle.setAttribute('r', radius);
                circle.setAttribute('fill', 'none');
                circle.setAttribute('stroke', difficulty.color);
                circle.setAttribute('stroke-width', '2.5');
                circle.setAttribute('stroke-opacity', '0.7');
                svg.appendChild(circle);
                
                const centerShadow = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                centerShadow.setAttribute('cx', centerX + 1);
                centerShadow.setAttribute('cy', centerY + 1);
                centerShadow.setAttribute('r', '8');
                centerShadow.setAttribute('fill', 'rgba(0,0,0,0.2)');
                svg.appendChild(centerShadow);
                
                const centerDot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                centerDot.setAttribute('cx', centerX);
                centerDot.setAttribute('cy', centerY);
                centerDot.setAttribute('r', '8');
                centerDot.setAttribute('fill', difficulty.color);
                centerDot.setAttribute('stroke', 'white');
                centerDot.setAttribute('stroke-width', '3');
                svg.appendChild(centerDot);
                
                for (let i = 0; i < numBranches; i++) {
                    const angle = (i * 2 * Math.PI) / numBranches - Math.PI / 2;
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;
                    
                    const lineEndX = centerX + Math.cos(angle) * 15;
                    const lineEndY = centerY + Math.sin(angle) * 15;
                    
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', x);
                    line.setAttribute('y1', y);
                    line.setAttribute('x2', lineEndX);
                    line.setAttribute('y2', lineEndY);
                    line.setAttribute('stroke', difficulty.color);
                    line.setAttribute('stroke-width', '2.5');
                    line.setAttribute('stroke-linecap', 'round');
                    line.setAttribute('marker-end', `url(#arrowhead-${difficulty.code})`);
                    line.setAttribute('opacity', '0.7');
                    svg.appendChild(line);
                    
                    const dotShadow = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    dotShadow.setAttribute('cx', x + 1);
                    dotShadow.setAttribute('cy', y + 1);
                    dotShadow.setAttribute('r', '5');
                    dotShadow.setAttribute('fill', 'rgba(0,0,0,0.15)');
                    svg.appendChild(dotShadow);
                    
                    const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    dot.setAttribute('cx', x);
                    dot.setAttribute('cy', y);
                    dot.setAttribute('r', '5');
                    dot.setAttribute('fill', difficulty.color);
                    dot.setAttribute('stroke', 'white');
                    dot.setAttribute('stroke-width', '2');
                    svg.appendChild(dot);
                }
            }
            
            return svg;
        }

        function createTableRow(difficulty) {
            const row = document.createElement('tr');
            row.className = 'table-row';
            
            const tierClass = `tier-${difficulty.tier.toLowerCase()}`;
            
            row.innerHTML = `
                <td class="table-cell">
                    <div class="difficulty-code" style="background-color: ${difficulty.color}20; color: ${difficulty.color}">
                        ${difficulty.code}
                    </div>
                </td>
                <td class="table-cell">
                    <div class="difficulty-score" style="background-color: ${difficulty.color}20; color: ${difficulty.color}">
                        ${difficulty.score}
                    </div>
                </td>
                <td class="table-cell">
                    <div class="tier-badge ${tierClass}">
                        ${difficulty.tier}
                    </div>
                </td>
                <td class="table-cell">
                    <div class="difficulty-description">
                        ${difficulty.description}
                    </div>
                </td>
                <td class="table-cell pattern-cell">
                    <div class="concentric-diagram"></div>
                </td>
            `;
            
            const diagram = row.querySelector('.concentric-diagram');
            diagram.appendChild(createConcentricDiagram(difficulty));
            
            return row;
        }

        const tbody = document.getElementById('difficulty-table-body');
        if (tbody) {
            difficulties.forEach(difficulty => {
                tbody.appendChild(createTableRow(difficulty));
            });
        }
    })();
</script>


## Format Specification

### Encoding Format

```
{Pattern}{Difficulty}
```

- **Pattern**: Describes the JOIN structure (e.g., `0`, `1p`, `2i`)
- **Difficulty**: Describes the filter complexity (e.g., `E`, `M`, `H`)

### Examples

- `0E`: Direct query, Easy
- `1pM`: Single-hop path, Medium
- `2iE`: Two-way intersection, Easy
- `2iH`: Two-way intersection, Hard
- `3iM`: Three-way intersection, Medium

---

## Pattern Types

Pattern types describe the **JOIN structure** of the query, inspired by Query Graph notation from Knowledge Graph QA research.

### Pattern Notation

| Code | Name                   | Description                      | JOIN Type | Example                                                         |
| ---- | ---------------------- | -------------------------------- | --------- | --------------------------------------------------------------- |
| `0`  | Direct                 | No JOIN, query only target table | None      | Find orders with status='completed'                             |
| `1p` | Single-hop Path        | 1 JOIN in a chain                | Chain     | Find orders from Healthcare customers                           |
| `2p` | Two-hop Path           | 2 JOINs in a chain               | Chain     | Find orders from US-West region customers                       |
| `3p` | Three-hop Path         | 3 JOINs in a chain               | Chain     | Orders → Customers → Regions → Countries                        |
| `2i` | Two-way Intersection   | 2 JOINs in a star                | Star      | Find orders: Healthcare customers × Software products           |
| `3i` | Three-way Intersection | 3 JOINs in a star                | Star      | Orders: Healthcare customers × Software products × Senior sales |
| `4i` | Four-way Intersection  | 4 JOINs in a star                | Star      | Orders with 4 independent filter dimensions                     |
| `Xm` | Mixed                  | Complex combination              | Mixed     | Chain + Star combinations                                       |

### Path vs Intersection

#### Path Queries (`Xp`)

**Structure**: Chain/Sequential JOINs

```
Target → Table1 → Table2 → ... → TableN
```

**Characteristics**:

- **Transitive reasoning** required
- Each table depends on the previous one
- Example schema: `Orders → Customers → Regions`

**SQL Pattern**:

```sql
SELECT o.*
FROM orders o
JOIN customers c ON o.customer_id = c.id
JOIN regions r ON c.region_id = r.id
WHERE r.name = 'US-West'
```

**Cognitive Complexity**:

- Understanding indirect relationships
- Multi-step inference
- Harder to trace the reasoning path

---

#### Intersection Queries (`Xi`)

**Structure**: Star/Parallel JOINs
```
      Table1
        ↓
    Target (center)
        ↓
      Table2
```

**Characteristics**:

- **Conjunction reasoning** required
- Independent filter conditions
- Example schema: `Orders` connects to both `Customers` and `Products`

**SQL Pattern**:

```sql
SELECT o.*
FROM orders o
JOIN customers c ON o.customer_id = c.id
JOIN products p ON o.product_id = p.id
WHERE c.industry = 'Healthcare'
  AND p.category = 'Software'
```

**Cognitive Complexity**:

- Understanding multi-dimensional constraints
- Combining independent conditions
- Requires awareness of multiple relationships simultaneously

---

### Pattern Hierarchy

```
Easy:    0
         ↓
Medium:  1p
         ↓
Hard:    2p, 2i
         ↓
Expert:  3p, 3i, 4i, Xm
```

**Note**: At the same hop count, chain (`Xp`) and star (`Xi`) have similar base difficulty, but chain queries typically require slightly more complex transitive reasoning.

---

## Difficulty Levels

Difficulty levels describe the **filter complexity** based on the number of distinct columns used in filter conditions.

### Difficulty Notation

| Code | Name   | Column Count | Description                                        |
| ---- | ------ | ------------ | -------------------------------------------------- |
| `E`  | Easy   | 1-2 columns  | Simple, single-condition or dual-condition filters |
| `M`  | Medium | 3-5 columns  | Multiple filter conditions across tables           |
| `H`  | Hard   | 6+ columns   | Complex multi-dimensional filtering                |

### Column Counting Rules

**Count distinct columns used in WHERE conditions** across all tables involved:

#### Example 1: `1pE`

```sql
SELECT o.* FROM orders o
JOIN customers c ON o.customer_id = c.id
WHERE c.industry = 'Healthcare'
```
- Columns: `c.industry` (1 column) → **E** (Easy)

#### Example 2: `1pM`

```sql
SELECT o.* FROM orders o
JOIN customers c ON o.customer_id = c.id
WHERE c.industry = 'Healthcare'
  AND c.annual_revenue > 1000000
  AND o.amount > 10000
```
- Columns: `c.industry`, `c.annual_revenue`, `o.amount` (3 columns) → **M** (Medium)

#### Example 3: `2iH`

```sql
SELECT o.* FROM orders o
JOIN customers c ON o.customer_id = c.id
JOIN products p ON o.product_id = p.id
WHERE c.industry = 'Healthcare'
  AND c.region = 'US-West'
  AND c.annual_revenue > 1000000
  AND p.category = 'Software'
  AND p.price > 10000
  AND o.amount > 50000
```
- Columns: 6 distinct columns → **H** (Hard)

---

## Complete Difficulty Matrix

### Difficulty Codes and Scores

| Code    | Pattern    | Difficulty | Score | Tier   | Description                 |
| ------- | ---------- | ---------- | ----- | ------ | --------------------------- |
| **0E**  | Direct     | Easy       | 0.0   | Easy   | Direct filter, 1-2 columns  |
| **0M**  | Direct     | Medium     | 0.3   | Easy   | Direct filter, 3-5 columns  |
| **0H**  | Direct     | Hard       | 0.6   | Easy   | Direct filter, 6+ columns   |
| **1pE** | 1-hop Path | Easy       | 1.0   | Medium | Single JOIN, simple filter  |
| **1pM** | 1-hop Path | Medium     | 1.3   | Medium | Single JOIN, medium filter  |
| **1pH** | 1-hop Path | Hard       | 1.6   | Medium | Single JOIN, complex filter |
| **2pE** | 2-hop Path | Easy       | 2.0   | Hard   | 2-hop chain, simple         |
| **2pM** | 2-hop Path | Medium     | 2.3   | Hard   | 2-hop chain, medium         |
| **2pH** | 2-hop Path | Hard       | 2.6   | Hard   | 2-hop chain, complex        |
| **2iE** | 2-way Star | Easy       | 2.0   | Hard   | 2-way intersection, simple  |
| **2iM** | 2-way Star | Medium     | 2.3   | Hard   | 2-way intersection, medium  |
| **2iH** | 2-way Star | Hard       | 2.6   | Hard   | 2-way intersection, complex |
| **3pE** | 3-hop Path | Easy       | 3.0   | Expert | 3-hop chain, simple         |
| **3pM** | 3-hop Path | Medium     | 3.3   | Expert | 3-hop chain, medium         |
| **3pH** | 3-hop Path | Hard       | 3.6   | Expert | 3-hop chain, complex        |
| **3iE** | 3-way Star | Easy       | 3.0   | Expert | 3-way intersection, simple  |
| **3iM** | 3-way Star | Medium     | 3.3   | Expert | 3-way intersection, medium  |
| **3iH** | 3-way Star | Hard       | 3.6   | Expert | 3-way intersection, complex |
| **4iE** | 4-way Star | Easy       | 4.0   | Expert | 4-way intersection, simple  |
| **4iM** | 4-way Star | Medium     | 4.3   | Expert | 4-way intersection, medium  |
| **4iH** | 4-way Star | Hard       | 4.6   | Expert | 4-way intersection, complex |

### Tier Boundaries

- **Easy Tier**: Score 0.0 - 0.9 (0E, 0M, 0H)
- **Medium Tier**: Score 1.0 - 1.9 (1pE, 1pM, 1pH)
- **Hard Tier**: Score 2.0 - 2.9 (2pE, 2pM, 2pH, 2iE, 2iM, 2iH)
- **Expert Tier**: Score 3.0+ (3p*, 3i*, 4i*, Xm*)

---

## Concrete Examples

### Schema Context

```
customers (10 rows)
├─ id, name, industry, region, annual_revenue, created_date

orders (20 rows) [TARGET TABLE]
├─ id, customer_id (FK), product_id (FK), amount, quantity,
│  order_date, status, sales_rep_id (FK)

products (10 rows)
├─ id, name, category, price, description

sales_reps (5 rows)
├─ id, name, seniority, region

regions (4 rows)
├─ id, name, country, tax_rate
```

### Example Questions by Difficulty

#### Easy Tier (0.0 - 0.9)

**0E** (Score: 0.0)

- Question: "Find all completed orders"
- Filter: `status = 'completed'`
- SQL: `SELECT * FROM orders WHERE status = 'completed'`

**0M** (Score: 0.3)

- Question: "Find completed orders with amount greater than $10,000"
- Filters: `status`, `amount` (2 columns)
- SQL: `SELECT * FROM orders WHERE status = 'completed' AND amount > 10000`

**0H** (Score: 0.6)

- Question: "Find completed orders with amount > $10,000, quantity > 5, placed after 2024-01-01"
- Filters: `status`, `amount`, `quantity`, `order_date` (4 columns)

---

#### Medium Tier (1.0 - 1.9)

**1pE** (Score: 1.0)

- Question: "Find all orders from Healthcare industry customers"
- Pattern: Orders → Customers
- Filters: `customers.industry` (1 column)
- SQL:
  ```sql
  SELECT o.* FROM orders o
  JOIN customers c ON o.customer_id = c.id
  WHERE c.industry = 'Healthcare'
  ```

**1pM** (Score: 1.3)

- Question: "Find orders from Healthcare customers with annual revenue > $1M"
- Pattern: Orders → Customers
- Filters: `customers.industry`, `customers.annual_revenue` (2 columns)
- SQL:
  ```sql
  SELECT o.* FROM orders o
  JOIN customers c ON o.customer_id = c.id
  WHERE c.industry = 'Healthcare'
    AND c.annual_revenue > 1000000
  ```

**1pH** (Score: 1.6)

- Question: "Find high-value orders from US Healthcare customers with revenue > $1M created after 2020"
- Pattern: Orders → Customers
- Filters: `customers.industry`, `customers.region`, `customers.annual_revenue`,
           `customers.created_date`, `orders.amount` (5 columns)

---

#### Hard Tier (2.0 - 2.9)

**2pE** (Score: 2.0)

- Question: "Find all orders from US-West region customers"
- Pattern: Orders → Customers → Regions (chain)
- Filters: `regions.name` (1 column)
- SQL:
  ```sql
  SELECT o.* FROM orders o
  JOIN customers c ON o.customer_id = c.id
  JOIN regions r ON c.region_id = r.id
  WHERE r.name = 'US-West'
  ```

**2iE** (Score: 2.0)

- Question: "Find orders from Healthcare customers buying Software products"
- Pattern: Orders ← Customers, Orders ← Products (star)
- Filters: `customers.industry`, `products.category` (2 columns)
- SQL:
  ```sql
  SELECT o.* FROM orders o
  JOIN customers c ON o.customer_id = c.id
  JOIN products p ON o.product_id = p.id
  WHERE c.industry = 'Healthcare'
    AND p.category = 'Software'
  ```

**2iM** (Score: 2.3)

- Question: "Find orders from US Healthcare customers buying Enterprise Software"
- Pattern: Orders ← Customers, Orders ← Products (star)
- Filters: `customers.industry`, `customers.region`,
           `products.category`, `products.name` (4 columns)

**2iH** (Score: 2.6)

- Question: "Find high-value orders from US Healthcare customers with revenue > $1M buying expensive Enterprise Software"
- Pattern: Star with 2 foreign tables
- Filters: 6+ columns across customers, products, and orders

---

#### Expert Tier (3.0+)

**3iE** (Score: 3.0)

- Question: "Find orders from Healthcare customers buying Software, handled by Senior sales reps"
- Pattern: Orders ← Customers, Orders ← Products, Orders ← Sales_Reps (3-way star)
- Filters: `customers.industry`, `products.category`, `sales_reps.seniority` (3 columns)
- SQL:
  ```sql
  SELECT o.* FROM orders o
  JOIN customers c ON o.customer_id = c.id
  JOIN products p ON o.product_id = p.id
  JOIN sales_reps s ON o.sales_rep_id = s.id
  WHERE c.industry = 'Healthcare'
    AND p.category = 'Software'
    AND s.seniority = 'Senior'
  ```

**3pE** (Score: 3.0)

- Question: "Find orders from customers in California, USA"
- Pattern: Orders → Customers → Regions → Countries (3-hop chain)
- Filters: `countries.name`, `regions.name` (2 columns)
- Requires: Extended schema with country-level data

---

## Implementation Guide

### Difficulty Calculator Class

```python
from dataclasses import dataclass
from typing import List, Set
from enum import Enum
import math

class PatternType(Enum):
    DIRECT = "0"
    PATH_1 = "1p"
    PATH_2 = "2p"
    PATH_3 = "3p"
    INTERSECTION_2 = "2i"
    INTERSECTION_3 = "3i"
    INTERSECTION_4 = "4i"
    MIXED = "Xm"

class DifficultyLevel(Enum):
    EASY = "E"
    MEDIUM = "M"
    HARD = "H"

@dataclass
class QueryPlan:
    """Represents a parsed query plan"""
    target_table: str
    target_columns: Set[str]
    join_paths: List['JoinPath']
    filter_columns: Set[str]  # All columns used in WHERE clause

@dataclass
class JoinPath:
    """Represents a JOIN path"""
    tables: List[str]
    join_type: str  # 'chain' or 'star'

class DifficultyClassifier:

    def classify(self, query_plan: QueryPlan) -> str:
        """
        Classify a query plan into difficulty code

        Returns:
            Difficulty code (e.g., "2iM")
        """
        pattern = self._identify_pattern(query_plan)
        difficulty = self._assess_difficulty(query_plan)

        return f"{pattern.value}{difficulty.value}"

    def _identify_pattern(self, query_plan: QueryPlan) -> PatternType:
        """Identify the pattern type"""
        num_joins = len(query_plan.join_paths)

        if num_joins == 0:
            return PatternType.DIRECT

        # Check if all JOINs are direct to target (star pattern)
        is_star = all(
            len(path.tables) == 2 for path in query_plan.join_paths
        )

        if is_star:
            # Star/Intersection pattern
            if num_joins == 1:
                return PatternType.PATH_1  # Actually still a path
            elif num_joins == 2:
                return PatternType.INTERSECTION_2
            elif num_joins == 3:
                return PatternType.INTERSECTION_3
            elif num_joins >= 4:
                return PatternType.INTERSECTION_4
        else:
            # Path/Chain pattern
            max_depth = max(len(path.tables) for path in query_plan.join_paths)
            if max_depth == 2:
                return PatternType.PATH_1
            elif max_depth == 3:
                return PatternType.PATH_2
            elif max_depth >= 4:
                return PatternType.PATH_3

        return PatternType.MIXED

    def _assess_difficulty(self, query_plan: QueryPlan) -> DifficultyLevel:
        """Assess difficulty based on filter complexity"""
        num_filter_columns = len(query_plan.filter_columns)

        if num_filter_columns <= 2:
            return DifficultyLevel.EASY
        elif num_filter_columns <= 5:
            return DifficultyLevel.MEDIUM
        else:
            return DifficultyLevel.HARD

    def get_score(self, difficulty_code: str) -> float:
        """Convert difficulty code to numeric score"""
        # Parse pattern and difficulty
        if difficulty_code[0].isdigit():
            if len(difficulty_code) >= 2 and difficulty_code[1] in ['p', 'i']:
                pattern_str = difficulty_code[:2]
                diff_str = difficulty_code[2:]
            else:
                pattern_str = difficulty_code[0]
                diff_str = difficulty_code[1:]
        else:
            pattern_str = difficulty_code[:2]
            diff_str = difficulty_code[2:]

        # Pattern base scores
        pattern_scores = {
            "0": 0.0,
            "1p": 1.0,
            "2p": 2.0,
            "2i": 2.0,
            "3p": 3.0,
            "3i": 3.0,
            "4i": 4.0,
            "Xm": 5.0,
        }

        # Difficulty modifiers
        difficulty_modifiers = {
            "E": 0.0,
            "M": 0.3,
            "H": 0.6,
        }

        base = pattern_scores.get(pattern_str, 0.0)
        modifier = difficulty_modifiers.get(diff_str, 0.0)

        return base + modifier
```

### Usage Example

```python
classifier = DifficultyClassifier()

# Example query plan
query_plan = QueryPlan(
    target_table="orders",
    target_columns={"id", "amount", "status"},
    join_paths=[
        JoinPath(tables=["orders", "customers"], join_type="star"),
        JoinPath(tables=["orders", "products"], join_type="star")
    ],
    filter_columns={"customers.industry", "products.category"}
)

difficulty_code = classifier.classify(query_plan)
print(difficulty_code)  # Output: "2iE"

score = classifier.get_score(difficulty_code)
print(score)  # Output: 2.0
```

---

## Dataset Distribution Recommendations

### Balanced Distribution

For a balanced QA dataset suitable for training and evaluation:

| Tier       | Target % | Difficulty Codes                                 |
| ---------- | -------- | ------------------------------------------------ |
| **Easy**   | 30%      | 0E (15%), 0M (10%), 0H (5%)                      |
| **Medium** | 50%      | 1pE (20%), 1pM (20%), 1pH (10%)                  |
| **Hard**   | 15%      | 2pE (3%), 2pM (3%), 2iE (3%), 2iM (3%), 2iH (3%) |
| **Expert** | 5%       | 3pE (2%), 3iE (2%), 3iM (1%)                     |

---

## Theoretical Foundation

### Query Graph Framework

This classification system is based on **Query Graph** frameworks from Knowledge Graph QA research, particularly:

1. **Path Queries**: Sequential edge traversal in knowledge graphs
   - Adapted to: Chain JOINs in relational databases
   - Notation: `1p`, `2p`, `3p`

2. **Intersection Queries**: Multiple edges converging at a node
   - Adapted to: Star schema JOINs
   - Notation: `2i`, `3i`, `4i`

3. **Union/Negation Queries**: (Not currently used)
   - Could be extended for `UNION`, `EXCEPT`, `NOT EXISTS` patterns

### Comparison to SQL Complexity Metrics

Traditional SQL complexity metrics (e.g., Spider, WikiSQL) focus on:

- Number of SELECT clauses
- Aggregation functions (COUNT, SUM, AVG)
- GROUP BY, HAVING, ORDER BY
- Subqueries and nested queries
- Window functions

**Our system differs** by:

- ✅ Focusing on **record localization** rather than complex SQL operations
- ✅ Emphasizing **JOIN structure** (graph topology)
- ✅ Separating **structural complexity** (pattern) from **filter complexity** (difficulty)
- ✅ Ignoring aggregation and sorting (not relevant for record retrieval)

### Why This Matters for Talk2Metadata

Talk2Metadata is a **semantic search system** for database records. Users want to:

- "Find orders from Healthcare customers" (1pE)
- "Find orders matching specific product and customer criteria" (2iE)

They typically **don't** need:

- Complex aggregations ("What is the average order value by region?")
- Window functions ("Rank customers by revenue")
- Subqueries ("Find customers with above-average orders")

Our classification aligns with this **retrieval-focused** use case.

---

## Extensions and Future Work

### Potential Extensions

1. **Mixed Patterns** (`Xm`)
   - Combination of chain + star (e.g., 2p + 2i)
   - Scoring formula: `base = max_hop_count + num_intersections * 0.5`

2. **Negation Patterns** (`Xn`)
   - Queries with `NOT EXISTS`, `EXCEPT`
   - Example: "Find customers who never bought Software products"

3. **Temporal Patterns** (`Xt`)
   - Time-based filtering requiring temporal reasoning
   - Example: "Find customers active in Q1 but not Q2"

4. **Aggregation Overlay** (Optional suffix)
   - `2iE-agg`: 2-way intersection with aggregation
   - Only if aggregation becomes important for your use case

### Schema-Specific Calibration

For specific database schemas, you may want to:

1. **Adjust column count thresholds** based on your typical table widths
   - Wide tables (50+ columns): E=1-3, M=4-8, H=9+
   - Narrow tables (<10 columns): E=1-2, M=3-4, H=5+

2. **Weight certain tables** as inherently more complex
   - Dimension tables (customers, products): Lower weight
   - Fact tables with many FKs: Higher weight

3. **Consider domain complexity**
   - Technical/medical domains: Adjust upward
   - Simple e-commerce: Keep as-is

---

## FAQ

### Q: Why distinguish 2p from 2i?

**A**: They represent fundamentally different reasoning patterns:

- **2p (chain)**: Requires transitive reasoning (A→B→C)
- **2i (star)**: Requires parallel filtering (A∧B from center)

Both are "hard" (score 2.0+), but the cognitive processes differ.

### Q: What if a query has both chain AND star?

**A**: Use the `Xm` (mixed) pattern or choose the dominant pattern:

- If primarily chain: Use `Xp`
- If primarily star: Use `Xi`
- If truly complex: `Xm` with custom scoring

### Q: Can I add intermediate levels like `VH` (Very Hard)?

**A**: Yes, but keep it simple. If needed:

- `E`: 1-2 columns
- `M`: 3-4 columns
- `H`: 5-6 columns
- `VH`: 7+ columns

Update the scoring formula accordingly (+0.2, +0.4, +0.6, +0.8).

### Q: How to handle self-joins?

**A**: Treat as an additional hop:

- Self-join on same table = +1 hop
- Example: "Find employees managed by senior managers" (employee → employee)

### Q: What about optional JOINs (LEFT JOIN)?

**A**: Same classification as INNER JOIN:

- Pattern is determined by structure, not JOIN type
- Optionality affects result cardinality, not reasoning complexity

---